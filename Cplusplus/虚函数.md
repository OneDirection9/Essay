# 引言

C++ 编译时期的多态性是通过重载来实现的。（也叫函数的多态性）

C++ 运行时多态性是通过虚函数来实现的。（也叫类的多态性）

类的**静态成员函数**和**构造函数**不能够声明为虚函数。当我们通过new来创建一个对象的时候，第一步是申请需要的内存，第二步就是调用构造函数。试想，如果构造函数是虚函数，那必然需要通过vtbl来找到虚构造函数的入口地址，显然，我们申请的内存还没有做任何初始化，不可能有vtbl的。因此，构造函数不能是虚函数。静态成员函数独立于对象而存在，无法通过虚函数实现多态，而且也不需要。

# 虚函数表

虚函数表参考[这里](http://blog.csdn.net/haoel/article/details/1948051/)。

只有同名且参数相同的虚函数会放在虚函数表的相同位置。

# 虚函数表与虚表指针

这个[链接](http://www.cnblogs.com/cxq0017/p/6074247.html)对虚函数与虚指针的描述清晰一点。上面介绍了虚函数表的结构，这边结合虚表指针来说明调用时具体调用哪个函数的问题。

1. 当要构造子类Son的对象时，先调用父类Father的构造函数去构造父类的对象，然后再调用子类的构造函数完成自身的构造，这两部分拼接出一个完整的子类Son对象。当将子类对象转换为父类类型时，该对象就被认为是父类对象。通过该对象调用函数（*非虚函数*）时，也就是调用父类的方法。  

    例如下面程序，运行结果是`Father say hello`.

    ```cpp
    #include <iostream> 
    using namespace std; 

    class Father {
    public:
        void Face() {
            cout << "Father's face" << endl;
        }
        void Say() {
         cout << "Father say hello" << endl;
        }
    };

    class Son:public Father {
    public:     
        void Say() {
            cout << "Son say hello" << endl;
        }
    };

    void main() {
        Son son;
        Father *pFather=&son; // 隐式类型转换
        pFather->Say(); //Father say hello
    }
    ```
    
2. 将Say()函数声明为虚函数，可以实现调用子类的方法。下面代码的输出就是`Son say hello`。

    ```cpp
    #include <iostream> 
    using namespace std; 

    class Father {
    public:
        void Face() {
            cout << "Father's face" << endl;
        }

        virtual void Say() {
            cout << "Father say hello" << endl;
        }
    };
    
    class Son:public Father {
    public:     
        void Say() {
            cout << "Son say hello" << endl;
        }
    };

    void main() {
        Son son;
        Father *pFather=&son; // 隐式类型转换
        pFather->Say();
    }
    ```
    
> 只要父类中声明为虚函数，子类中函数名相同、参数结构相同的函数都会看做虚函数。

编译器在编译的时候，发现基类Father中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即vtable），该表是一个数组，在这个数组中存放每个虚函数的地址。当父类出现虚函数的时候，子类中就会复制父类的虚函数表，存在自己的对象中。如果重写了虚函数，相应位置的函数地址就会改为指向自己的虚函数地址。
 
那么如何定位虚表呢？编译器另外还为每个类的对象提供了一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表。所以在调用虚函数时，就能够找到正确的函数。编译器为每个对象提供了虚表指针(即vptr)。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的虚表，从而在调用虚函数的时候，能够找到正确的函数。
 
> 对于上述程序，由于pFather实际指向的对象类型是Son，因此vptr指向的Son类的vtable，当调用pFather->Say()时，根据虚表中的函数地址找到的就是Son类的Say()函数。
 
## 虚表指针的初始化

那么虚表指针在什么时候，或者说在什么地方初始化呢？

答案是在构造函数中进行虚表的创建和虚表指针的初始化。
 
还记得构造函数的调用顺序吗，在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否后还有继承者，它初始化父类对象的虚表指针，该虚表指针指向父类的虚表。当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。
> 对于以上的例子，当Son类的对象构造完毕后，其内部的虚表指针也就被初始化为指向Son类的虚表。在类型转换后，调用pFather->Say()，由于pFather实际指向的是Son类的对象，该对象内部的虚表指针指向的是Son类的虚表，因此最终调用的是Son类的Say()函数。
 
要**注意**：对于虚函数调用来说，每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。
    

> 拿上面的代码为例，将son对象赋值给father指针，因此vptr指向的还是son类的vtable，当调用虚函数时，就会在son类虚函数表里面进行查找调用。

**隐藏规则**：

这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1. 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual
关键字，基类的函数将被隐藏（注意别与重载混淆）。
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual
关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

> 隐藏发生在派生类的对象调用函数时候。如果是基类的对象调用函数时候，只会发生虚函数调用，其他函数还是基类的函数。

**总结**：

1. 每个类都有一个虚表
2. 存在虚函数的类都有一个虚函数表叫做虚表。类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。
2. 虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。如果基类有3个虚函数，那么基类的虚表中就有三项(虚函数地址)，派生类也会虚表，至少有三项，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现，如果派生类有自己的虚函数，那么虚表中就会添加该项。
3. 派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。
4. 一般情况下(不涉及虚函数)，当我们用一个指针/引用调用一个函数的时候，被调用的函数是取决于这个指针/引用的类型。
> 例如基类指针被赋予子类对象，调用非虚函数还是基类的函数。

# 纯虚函数

将虚函数加上=0，并且没有函数体，就将函数声明为纯虚函数。纯虚函数所在类的派生类必须实现纯虚函数，否则会报错。

**抽象类**是指包括至少一个纯虚函数的类。

```cpp
class pV{
    virtual void t(void) = 0;
}
```

# 函数指针

函数参考[这里](http://www.cnblogs.com/zrtqsk/p/4254765.html)。

**最简单的函数指针**

函数指针的声明很简单，基本就是通过一个指针把函数名替换。
> 函数名add就是函数的地址

```cpp
#include <iostream>
using namespace std;

void add(int a, int b) {
	cout << a + b << endl;
}

int main() {
	void (*p) (int a, int b);
	p = add;

	p(1, 2);	// 3
	(*p)(3, 4); // 7
	return 0;
}
```

**包含多个函数指针的数组**

与[数组指针，指针数组](http://www.cnblogs.com/mq0036/p/3382732.html)类似。
　　
```cpp
void (*p2[2])(int a, int b);
```

数组名为p2，数组大小为2，数组中元素类型为void (*)(int a, int b)，表明元素是一个指向某个函数的指针，指针指向的类型为void () (int a,int b)。

***

Author: Zhipeng Han

Time: 2017/03/26
